# Overview
- This document covers the implementation of L-BFGR methods for QSP protocol optimization as covered in [this paper](https://arxiv.org/pdf/2002.11649) and [this package subroutine](https://github.com/qsppack/QSPPACK/blob/master/Solvers/Optimization/QSP_solver.m)

## Required components
- Overall QSP solver file
	- Input parameters in original `QSP_solver.m`
		- Max iterations
		- Stop criteria
		- Whether to use real arithmetic or not
		- Whether to use `Pre` as target function
		- Method selection (for us, we will always use LBFGS)
		- Whether to use full or reduced phase factors
	- Output parameters in original `QSP_solver.m`
		- Full phase factors
		- Other metadata
- Order of current computation
	- For within LBFGS
		- Given total length of coefficients, compute `delta`]
		- Set target, depending on `Pre` flat (*currently not understood*), to a returned value computed by `ChebyCoef2Func`, which takes in x, coefficients, and parity arguments. Note this creates an anonymous function depending on (x, opts), where opts is the metadata discussed above.
		- Generates a series of objects
			- obj is set to `@QSPObj_sym`
			- grad is set to `@QSPGrad_sym` or `QSPGrad_sym_real` depending on real flag
		- *MAIN FUNCTION CALL*
			- The LFBGS solver module is called, which returns `phi`, `err`, and `iter` data, and takes in `obj` and `grad` from above, as well as `delta` and metadata
			- *NOTE*: depending on parity, initial phase is halved
		- Phases are returned, possibly calling `rdc_phase_factor_to_full` if they were reduced
			- *QUESTION*: if we work only with non-reduced factors, is it difficult to ensure the proper optimization?

## Notes on `QSP_LBFGS.m` file, called as main subroutine
- Overall structure
	- Input
		- `obj`: objective function L(phi); generated by `@QSPObj_sym`.
		- `grad`: gradient of object function.
		- `delta`: number of samples.
		- `phi`: initial value.
		- `opts`: metadata.
			- maxiter, gamma (linesearch retraction rate), accrate (linesearch accept ratio), minstep, criteria (*stop criteria for obj value on Chevyshev points*), lmem (memory size), print (whether to output), itprint, parity ((0 -- even, 1 -- odd)), target (polynomial)
	- Output
		- phi
		- error of final effort according to loss
		- iteration number
	- Set and initialize all metadata as given
	- Call and initial gradient and objects
		- Call `grad(phi,delta,opts)` to get `grad_s` and `obj_s`
		- Compute means of these values (presumably sampled over)
		- Initial `obj_value` and `GRAD` as the first mean, and the second mean's transpose
	- Then we iterate while true
		- Start with `GRAD` and `alpha` (zero list the size of lmem), and then we perform two loops
			- *FIRST LOOP*
				- Looping over lmem size, we update alpha(i) according to some strange indexing scheme dependent theta_d (`GRAD` initially) and all of (initially zero)
					- `mem_dot`: (lmem)
					- `mem_obj`: (lmem, d), for d len(phi)
					- `mem_grad`: (lmem, d)
				- Then depending on parity rescaling first phase again
			- *SECOND LOOP*
				- Now we generate `beta` with 
					- `mem_size` and `mem_now` scalars
				- This depends on `mem_grad`, `mem_dot`, `mem_obj`, and `alpha`, with self updates.
		- We reach another if True loop
			- Computes a new set of phases according to `step` and `theta_d`
			- Computes objective function on new phases
			- Computes mean of those objectives
			- Computes how much change from last iteration `ad`
			- Breaks if step gets too small (decreasing multiplicatively by gamma), or *if too large?*
		- Then we move onto a final step in the outer overall loop
			- Set as phi the temp theta found in previous step
			- Compute the objective and the *MAX* of those samples
			- Compute a new gradient
			- Update all the `mem_` objects from before by real values
				- `mem_size` is increased by one until limit lmem 
				- `mem_now` is increased by one (and modulo lmem)
				- `mem_grad` (Column `mem_now`) is updated to the difference in gradient before and after
				- `mem_obj` (Column `mem_now`) is taken to be `-step` times`theta_d`
				- `mem_dot` (at index `mem_now`) is taken as the inner product of the `mem_now`-th column of `mem_grad` and `mem_obj` (the latter transposed).
			- The `GRAD` is updated to the new grad computed
		- We end if one of two conditions is met
			- We reach `max_iter`
			- If the worst case `obj_max` objective error computed above is less than `crit` (*SQUARED* for some reason).


## On computing gradients
- Located in `QSPGrad_sym.m` and symmetrized real version
	- *NOTE: THIS SECTION IS UNFINISHED*
	- Computes the gradient with respect to each phase of the objective function, assuming that phi is symmetric.
	-
	-
	-
	-
	-

## On computing loss function
- The objective function should be contained in the grad computation, but is also called with `QSPObj_sym.m`
	- This performs very simple arithmetic on the top-right element of the unitary computed by `QSPGetUnit_sym.m` (half of the squared error for some reason)
		- *NOTES ON THE FORMAT OF THIS UNITARY*: Both this and `QSPGetUnitary.m` just perform the same repeated product of unitaries.
		- *NOTE FOR SYM WE ARE CONJUGATING BY THE RET GATE, WHICH LOOKS LIKE AN S GATE*. 
		- *NOTE*: target is specified by `ChebyCoef2Func` function at the top level
	- Comparison is made with `opts.target(delta(i))`; namely for each of the samples according to `delta`, the i-th component of this sample list has a function applied to it, and is compared with the real part of the QSP unitary element applied to the same `delta(i)`.

## On `ChebyCoef2Func.m`
- Takes the cheb coefficients and an argument and returns a function at that argument.
- *QUESTION*: unclear what the `Pre` (p real?) condition is at the top level module, which only changes the sign of the objective
- *NOTE*: this is different from `ChebyFunc2Coef`, which gives the chebyshev coefficients for a given polynomial up to a certain order.

## On other methods for optimization and standard phase finding
- Hessian and Jacobian use are restricted to Haah/GSLW method and strict Newton method respectively.

## Design notes
- Symmetric phases are used to achieve a given real part of the (1,1) component of the overall unitary
	- *NOTE*: optimization is often started from a fixed, non-zero initial state.
- Data types and class structure
	- Full or reduced phase factors; we could specify a full phases object, or a QSP object; something which contains, if one desires to query attributes of a protocol, everyone one wants to know. This could be instantiated in one of many ways. *NOTE: look at what the package currently does.*